<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <!-- å…³é”®ï¼šç¦æ­¢ç¼©æ”¾ï¼Œé€‚é…ç§»åŠ¨ç«¯è§†å£ -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>3D ç²’å­äº¤äº’ç³»ç»Ÿ</title>
    <style>
        /* --- æ²‰æµ¸å¼åŸºç¡€æ ·å¼ --- */
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body { 
            margin: 0; 
            padding: 0;
            overflow: hidden; 
            background-color: #000; 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Microsoft YaHei", sans-serif;
            width: 100vw;
            height: 100dvh; /* é€‚é…ç§»åŠ¨ç«¯åŠ¨æ€é«˜åº¦ */
        }
        canvas { display: block; width: 100%; height: 100%; }

        /* --- UI å®¹å™¨ --- */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 10;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        /* --- é¡¶éƒ¨ä¿¡æ¯æ  --- */
        .top-bar {
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        /* æ‘„åƒå¤´é¢„è§ˆ (å·¦ä¸Š) */
        #cam-box {
            width: 100px; height: 75px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: #000;
            overflow: hidden;
            transform: scaleX(-1);
            pointer-events: auto;
            transition: opacity 0.3s;
        }
        /* ç‚¹å‡»æ‘„åƒå¤´å¯éšè—/æ˜¾ç¤º */
        #cam-box.hidden { opacity: 0.1; }
        #input_video { width: 100%; height: 100%; object-fit: cover; }

        /* çŠ¶æ€æ–‡å­— (å³ä¸Š) */
        .status-box {
            text-align: right;
            text-shadow: 0 0 5px rgba(0,0,0,0.8);
        }
        #gesture-icon { font-size: 2rem; display: block; margin-bottom: 5px; }
        #mode-text { 
            color: #00ffff; font-size: 0.9rem; font-weight: bold; 
            background: rgba(0,0,0,0.4); padding: 4px 8px; border-radius: 4px;
        }

        /* --- åº•éƒ¨æ§åˆ¶æ  --- */
        .bottom-bar {
            padding: 20px;
            padding-bottom: max(20px, env(safe-area-inset-bottom)); /* é€‚é… iPhone åº•éƒ¨æ¨ªæ¡ */
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            pointer-events: auto;
            background: linear-gradient(to top, rgba(0,0,0,0.8), transparent);
        }

        /* æŒ‰é’®ä¸æ§ä»¶ */
        .control-group {
            background: rgba(30, 30, 30, 0.6);
            backdrop-filter: blur(8px);
            padding: 8px 15px;
            border-radius: 50px;
            border: 1px solid rgba(255,255,255,0.15);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .btn {
            background: none; border: none; color: white;
            font-size: 14px; cursor: pointer; padding: 5px 10px;
            border-radius: 20px; border: 1px solid rgba(255,255,255,0.2);
            white-space: nowrap;
        }
        .btn:active { background: rgba(255,255,255,0.2); transform: scale(0.95); }

        /* é¢œè‰²é€‰æ‹©å™¨ */
        #color-input {
            width: 28px; height: 28px;
            border: 2px solid white;
            border-radius: 50%;
            overflow: hidden;
            padding: 0;
            background: none;
            cursor: pointer;
        }
        #color-input::-webkit-color-swatch-wrapper { padding: 0; }
        #color-input::-webkit-color-swatch { border: none; }

        /* --- åŠ è½½å±‚ --- */
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: #00ffff; transition: opacity 0.5s;
        }
        .loading-text { margin-top: 15px; font-size: 14px; letter-spacing: 1px; }

    </style>
</head>
<body>

    <!-- åŠ è½½åŠ¨ç”» -->
    <div id="loader">
        <svg width="50" height="50" viewBox="0 0 50 50">
            <circle cx="25" cy="25" r="20" fill="none" stroke="#00ffff" stroke-width="4" stroke-dasharray="31.4 31.4">
                <animateTransform attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="1s" repeatCount="indefinite"/>
            </circle>
        </svg>
        <div class="loading-text">åˆå§‹åŒ– AI å¼•æ“...</div>
    </div>

    <!-- UI å±‚ -->
    <div id="ui-layer">
        <div class="top-bar">
            <!-- æ‘„åƒå¤´ (ç‚¹å‡»å¯æŠ˜å ) -->
            <div id="cam-box" onclick="this.classList.toggle('hidden')">
                <video id="input_video" playsinline muted autoplay></video>
            </div>
            
            <!-- çŠ¶æ€ä¿¡æ¯ -->
            <div class="status-box">
                <span id="gesture-icon">ğŸ‘‹</span>
                <div id="mode-text">è¯·åœ¨æ‘„åƒå¤´å‰å±•ç¤ºæ‰‹åŠ¿</div>
            </div>
        </div>

        <div class="bottom-bar">
            <div class="control-group">
                <input type="color" id="color-input" value="#00ffff" title="è°ƒæ•´ç²’å­é¢œè‰²">
                <span style="font-size:12px; color:#aaa;">é¢œè‰²</span>
            </div>
            <div class="control-group">
                <button class="btn" id="fullscreen-btn">â›¶ å…¨å±æ˜¾ç¤º</button>
            </div>
        </div>
    </div>

    <!-- éšè—ç”»å¸ƒç”¨äºç”Ÿæˆæ–‡å­— -->
    <canvas id="text-helper" style="display:none;"></canvas>

    <!-- æ ¸å¿ƒåº“ -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- é…ç½®å‚æ•° ---
        const CONFIG = {
            particleCount: 16000, // ç§»åŠ¨ç«¯ä¼˜åŒ–ï¼šå‡å°‘ç²’å­æ•°ä»¥é˜²å¡é¡¿
            baseSize: 0.6,
            color: new THREE.Color('#00ffff'),
            names: {
                1: "æ–¹æ¥šå…ƒ",
                2: "éƒ‘ç”°ç”°",
                3: "æ½˜é“­æ•",
                4: "é‚µå®‰å¦®"
            }
        };

        // --- å˜é‡ ---
        let scene, camera, renderer, particles, geometry, material;
        let targetPositions, currentPositions;
        let lastFingerCount = -1;

        // --- 1. åˆå§‹åŒ–åœºæ™¯ ---
        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.02);

            // æ‘„åƒæœºè§†åœºè§’
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            updateCameraPosition(); // æ ¹æ®å±å¹•æ¯”ä¾‹è°ƒæ•´ç›¸æœºè¿œè¿‘

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            // é™åˆ¶åƒç´ æ¯”ï¼Œçœç”µä¸”é˜²å¡é¡¿
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.6;
            controls.enablePan = false; // æ‰‹æœºä¸Šç¦æ­¢å¹³ç§»ï¼Œé˜²æ­¢è¯¯è§¦

            initParticles();
            
            // é»˜è®¤æ»¡å±çŠ¶æ€
            calculateChaosTargets();

            // äº‹ä»¶ç›‘å¬
            window.addEventListener('resize', onWindowResize);
            document.getElementById('fullscreen-btn').addEventListener('click', toggleFullScreen);
            document.getElementById('color-input').addEventListener('input', (e) => {
                CONFIG.color.set(e.target.value);
                material.color.set(CONFIG.color);
            });

            animate();
        }

        // --- é€‚é…ï¼šæ ¹æ®å±å¹•è°ƒæ•´ç›¸æœºä½ç½® ---
        function updateCameraPosition() {
            if (window.innerWidth < window.innerHeight) {
                // ç«–å±æ‰‹æœºï¼šç›¸æœºæ‹‰è¿œä¸€ç‚¹ï¼Œä¿è¯å†…å®¹ä¸è¢«åˆ‡æ–­
                camera.position.z = 70; 
            } else {
                // ç”µè„‘æˆ–æ¨ªå±
                camera.position.z = 50;
            }
        }

        // --- 2. ç²’å­ç³»ç»Ÿ ---
        function initParticles() {
            geometry = new THREE.BufferGeometry();
            const count = CONFIG.particleCount;
            
            currentPositions = new Float32Array(count * 3);
            targetPositions = new Float32Array(count * 3);

            for (let i = 0; i < count * 3; i++) {
                currentPositions[i] = (Math.random() - 0.5) * 100;
                targetPositions[i] = currentPositions[i];
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(currentPositions, 3));

            // ç¨‹åºç”Ÿæˆåœ†å½¢çº¹ç†
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16,16,0, 16,16,16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(0.5, 'rgba(255,255,255,0.3)');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,32,32);

            material = new THREE.PointsMaterial({
                size: CONFIG.baseSize,
                color: CONFIG.color,
                map: new THREE.CanvasTexture(canvas),
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        // --- 3. å½¢çŠ¶ç®—æ³• ---

        // 3.1 æ»¡å±æ‰©æ•£ (æ¢å¤)
        function calculateChaosTargets() {
            const count = CONFIG.particleCount;
            for (let i = 0; i < count; i++) {
                const i3 = i * 3;
                targetPositions[i3] = (Math.random() - 0.5) * 250;
                targetPositions[i3+1] = (Math.random() - 0.5) * 150;
                targetPositions[i3+2] = (Math.random() - 0.5) * 100;
            }
            material.size = CONFIG.baseSize;
        }

        // 3.2 çˆ±å¿ƒ (æ¡æ‹³)
        function calculateHeartTargets() {
            const count = CONFIG.particleCount;
            for (let i = 0; i < count; i++) {
                const i3 = i * 3;
                let t = Math.random() * Math.PI * 2;
                let x = 16 * Math.pow(Math.sin(t), 3);
                let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                let z = (Math.random() - 0.5) * 5;

                // ç«–å±æ—¶çˆ±å¿ƒç¨å¾®å°ä¸€ç‚¹
                const scale = window.innerWidth < window.innerHeight ? 1.0 : 1.3;

                if (i < count * 0.7) {
                    targetPositions[i3] = x * scale;
                    targetPositions[i3+1] = y * scale;
                    targetPositions[i3+2] = z * scale;
                } else {
                    targetPositions[i3] = (Math.random() - 0.5) * 200;
                    targetPositions[i3+1] = (Math.random() - 0.5) * 200;
                    targetPositions[i3+2] = (Math.random() - 0.5) * 100;
                }
            }
            material.size = CONFIG.baseSize * 1.5;
        }

        // 3.3 æ–‡å­— (1-4æŒ‡)
        function calculateTextTargets(text) {
            const canvas = document.getElementById('text-helper');
            const ctx = canvas.getContext('2d');
            canvas.width = 1024; canvas.height = 512;
            
            ctx.clearRect(0,0, canvas.width, canvas.height);
            ctx.font = "bold 180px 'Microsoft YaHei', sans-serif";
            ctx.fillStyle = "white";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(text, canvas.width/2, canvas.height/2);

            const imgData = ctx.getImageData(0,0,canvas.width,canvas.height).data;
            const validPoints = [];
            const step = 4;

            // --- æ ¸å¿ƒé€‚é…ï¼šåŠ¨æ€è®¡ç®—æ–‡å­—ç¼©æ”¾ ---
            // å¦‚æœæ˜¯æ‰‹æœºç«–å±ï¼Œç¼©å°æ¯”ä¾‹ (0.11)ï¼Œå¦‚æœæ˜¯ç”µè„‘ï¼Œæ­£å¸¸æ¯”ä¾‹ (0.18)
            const isPortrait = window.innerWidth < window.innerHeight;
            const scale = isPortrait ? 0.11 : 0.18;

            for (let y=0; y<canvas.height; y+=step) {
                for (let x=0; x<canvas.width; x+=step) {
                    if (imgData[(y*canvas.width+x)*4+3] > 128) {
                        validPoints.push({
                            x: (x - canvas.width/2) * scale,
                            y: -(y - canvas.height/2) * scale
                        });
                    }
                }
            }

            const count = CONFIG.particleCount;
            for (let i = 0; i < count; i++) {
                const i3 = i * 3;
                if (i < validPoints.length) {
                    targetPositions[i3] = validPoints[i].x;
                    targetPositions[i3+1] = validPoints[i].y;
                    targetPositions[i3+2] = 0;
                } else {
                    targetPositions[i3] = (Math.random() - 0.5) * 200;
                    targetPositions[i3+1] = (Math.random() - 0.5) * 200;
                    targetPositions[i3+2] = (Math.random() - 0.5) * 100;
                }
            }
            material.size = CONFIG.baseSize * 1.3;
        }

        // --- 4. å¾ªç¯åŠ¨ç”» ---
        function animate() {
            requestAnimationFrame(animate);
            
            const positions = geometry.attributes.position.array;
            const lerpSpeed = 0.08;

            for (let i = 0; i < CONFIG.particleCount; i++) {
                const i3 = i * 3;
                positions[i3] += (targetPositions[i3] - positions[i3]) * lerpSpeed;
                positions[i3+1] += (targetPositions[i3+1] - positions[i3+1]) * lerpSpeed;
                positions[i3+2] += (targetPositions[i3+2] - positions[i3+2]) * lerpSpeed;
                
                // çˆ±å¿ƒè·³åŠ¨
                if (lastFingerCount === 0) {
                    const beat = Math.sin(Date.now() * 0.005) * 0.03;
                    positions[i3] += positions[i3] * beat;
                    positions[i3+1] += positions[i3+1] * beat;
                }
            }

            geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }

        // --- 5. MediaPipe æ‰‹åŠ¿ ---
        function initHandTracking() {
            const video = document.getElementById('input_video');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(results => {
                const icon = document.getElementById('gesture-icon');
                const text = document.getElementById('mode-text');

                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const lm = results.multiHandLandmarks[0];
                    const fingers = countFingers(lm);

                    if (fingers !== lastFingerCount) {
                        lastFingerCount = fingers;
                        
                        if (fingers === 0) {
                            calculateHeartTargets();
                            icon.innerText = "â¤ï¸"; text.innerText = "çˆ±å¿ƒ (èšæ‹¢)";
                        } else if (fingers === 5) {
                            calculateChaosTargets();
                            icon.innerText = "âœ¨"; text.innerText = "æ»¡å±æ‰©æ•£";
                        } else if (CONFIG.names[fingers]) {
                            calculateTextTargets(CONFIG.names[fingers]);
                            icon.innerText = ["â˜ï¸", "âœŒï¸", "ğŸ‘Œ", "ğŸ––"][fingers-1];
                            text.innerText = CONFIG.names[fingers];
                        }
                    }
                }
            });

            const camera = new Camera(video, {
                onFrame: async () => { await hands.send({image: video}); },
                width: 320, height: 240
            });
            camera.start().then(() => {
                document.getElementById('loader').style.opacity = 0;
                setTimeout(() => document.getElementById('loader').style.display='none', 500);
            });
        }

        function countFingers(lm) {
            const tips = [8, 12, 16, 20];
            const pips = [6, 10, 14, 18];
            let c = 0;
            // å››æŒ‡
            for(let i=0; i<4; i++) if(lm[tips[i]].y < lm[pips[i]].y) c++;
            // æ‹‡æŒ‡
            const thumbDist = Math.hypot(lm[4].x - lm[17].x, lm[4].y - lm[17].y);
            const indexDist = Math.hypot(lm[5].x - lm[17].x, lm[5].y - lm[17].y);
            if(thumbDist > indexDist * 1.3) c++;
            return c;
        }

        // --- çª—å£é€‚é… ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            updateCameraPosition();
            
            // é‡æ–°è®¡ç®—æ–‡å­—å¤§å°é€‚é…æ–°å±å¹•
            if (lastFingerCount >= 1 && lastFingerCount <= 4) {
                calculateTextTargets(CONFIG.names[lastFingerCount]);
            }
        }

        // --- çœŸÂ·å…¨å±é€»è¾‘ ---
        function toggleFullScreen() {
            const elem = document.documentElement;
            if (!document.fullscreenElement) {
                // å°è¯•æ ‡å‡†å…¨å±
                if (elem.requestFullscreen) {
                    elem.requestFullscreen().catch(err => console.log(err));
                } else if (elem.webkitRequestFullscreen) { /* Safari */
                    elem.webkitRequestFullscreen();
                }
            } else {
                if (document.exitFullscreen) document.exitFullscreen();
            }
        }

        init();
        initHandTracking();
    </script>
</body>
</html>
